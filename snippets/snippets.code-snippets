{
    "simple_template": {
		"prefix": "stmplt",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"int main(void){",
			"\tint n,;",
			"\tll ans = 0;",
			"\tcin >> n;",
			"",
			"\treturn 0;",
			"}"
		],
		"description": "simple template"
	},
    "atcoder_template": {
        "prefix": "tmplt",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long;",
            "#define rep(i, n) for (ll i = 0; i < (n); i++)",
            "#define rep2(i,k,n) for(ll i = k;i < (n);i++)",
            "#define ALL(a) (a).begin(),(a).end()",
            "#define ALLR(a) (a).rbegin(),(a).rend()",
            "using P = pair<ll,ll>;",
            "const ll MOD = 998244353;",
            "const int INF = 1e9;",
            "const ll lINF = 1e18;",
            "const int dx[4] = {1, 0, -1, 0};",
            "const int dy[4] = {0, 1, 0, -1};",
            "template <class T> inline bool chmin(T &a, T b) {if (a > b) {a = b; return true;} return false;}",
            "template <class T> inline bool chmax(T &a, T b) {if (a < b) {a = b; return true;} return false;}\n",
            "template <class T>",
            "T GCD(T a, T b) {",
            "\tif (b == 0)",
            "\t\treturn a;",
            "\telse",
            "\t\treturn GCD(b, a % b);",
            "}\n",
            "template <class T>",
            "inline T LCM(T a, T b) {",
            "\t return b / GCD(a, b) * a;",
            "}\n",
            "template <class T>",
            "T nCr_naive(T n, int r) {",
            "\tT ret(1);",
            "\tfor (int i = 0; i < r; i++) {",
            "\t\tret *= n;",
            "\t\tret /= T(i + 1);",
            "\t\tn -= T(1);",
            "\t}",
            "\treturn ret;",
            "}\n",
            "int main(void){",
            "\tint n,$1;",
            "\tll ans = 0;",
            "\tcin >> n >> $1;",
            "\tvector<ll> a(n);",
            "\trep(i, n) cin >> a[i];\n",
            "\treturn 0;",
            "}"
        ],
        "description": "competitive programming template"
    },
    "atcoder_n_templt": {
        "prefix": "ntemplt",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long;",
            "#define rep(i, n) for (ll i = 0; i < (n); i++)",
            "#define rep2(i,k,n) for(ll i = k;i < (n);i++)",
            "#define ALL(a) (a).begin(),(a).end()",
            "#define ALLR(a) (a).rbegin(),(a).rend()",
            "using P = pair<ll,ll>;",
            "const ll MOD = 998244353;",
            "const int INF = 1e9;",
            "const ll lINF = 1e18;",
            "const int dx[4] = {1, 0, -1, 0};",
            "const int dy[4] = {0, 1, 0, -1};",
            "template <class T> inline bool chmin(T &a, T b) {if (a > b) {a = b; return true;} return false;}",
            "template <class T> inline bool chmax(T &a, T b) {if (a < b) {a = b; return true;} return false;}\n",
            "int main(void){",
            "\tint n;",
            "\tll ans = 0;",
            "\tcin >> n;",
            "\tvector<ll> $1(n);",
            "\trep(i, n) cin >> $1[i];\n\n",
            "\treturn 0;",
            "}"
        ],
        "description": "template for n and array of size n",
    },
    "n_m_template": {
        "prefix": "nmtmplt",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long;",
            "#define rep(i, n) for (ll i = 0; i < (n); i++)",
            "#define rep2(i,k,n) for(ll i = k;i < (n);i++)",
            "#define ALL(a) (a).begin(),(a).end()",
            "#define ALLR(a) (a).rbegin(),(a).rend()",
            "using P = pair<ll,ll>;",
            "const ll MOD = 998244353;",
            "const int INF = 1e9;",
            "const ll lINF = 1e18;",
            "const int dx[4] = {1, 0, -1, 0};",
            "const int dy[4] = {0, 1, 0, -1};",
            "template <class T> inline bool chmin(T &a, T b) {if (a > b) {a = b; return true;} return false;}",
            "template <class T> inline bool chmax(T &a, T b) {if (a < b) {a = b; return true;} return false;}\n",
            "int main(void){",
            "\tint n,$1;",
            "\tll ans = 0;",
            "\tcin >> n >> $1;",
            "\tvector<ll> $2(n);",
            "\trep(i, n) cin >> $2[i];\n\n",
            "\treturn 0;",
            "}"
        ],
        "description": "template for handling n and m"
    },
    "Double for-loop": {
		"prefix": "ffor",
		"body": [
			"for(int i = 0;i < $1;i++){",
			"\tfor(int j = 0;j < $2;j++){",
			"",
			"\t}",
			"}",
		],
	},
    "vector<int>": {
        "prefix": "vi",
        "body": "vector<int> $1;\n",
        "description": "vector<int>"
    },
    "vector<ll>": {
        "prefix": "vl",
        "body": "vector<ll> $1;\n",
        "description": "vector<ll>"
    },
    "vector<string>":{
        "prefix": "vs",
        "body": "vector<string> $1;\n",
        "description": "vector<string>"
    },
    "vector<vector<T>> ":{
        "prefix": "vv",
        "body": "vector<vector<$1>> $2($3,vector<$1>($4));\n",
        "description": "two-dimensional array",
    },
    "map<int,int>":{
        "prefix": "mpii",
        "body": "map<int,int> $1;\n",
        "description": "map<int,int>"
    },
    "map<ll,ll>":{
        "prefix": "mpll",
        "body": "map<ll,ll> $1;\n",
        "description": "map<ll,ll>"
    },
    "output newline":{
        "prefix": "oen",
        "body": "cout << $1 << endl;\n",
        "description": "output with newline"
    },
    "ans output": {
        "prefix": "oans",
        "body": "cout << ans << endl;",
        "description": "output ans"
    },
    "yes output": {
        "prefix": "oy",
        "body": "cout << \"yes\" << endl;\n",
        "description": "output yes"
    },
    "no output": {
        "prefix": "on",
        "body": "cout << \"no\" << endl;\n",
        "description": "oputput no"
    },
    "combination": {
        "prefix": "comb",
        "body": [
            "template <class T>",
            "T nCr_naive(T n, int r) {",
            "\tT ret(1);",
            "\tfor (int i = 0; i < r; i++) {",
            "\t\tret *= n;",
            "\t\tret /= T(i + 1);",
            "\t\tn -= T(1);",
            "}",
            "\treturn ret;",
            "}",
        ],
        "description": "combination calculation"
    },
    "Radix conversion": {
        "prefix": "convertb",
        "body": [
            "template <typename T>",
            "string convert_base(T x,T y){",
            "\tstring s;\n",
            "\twhile (x){",
            "\t\ts = to_string(x % y) + s;",
            "\t\tx /= y;",
            "\t}",
            "\treturn s;",
            "}",
            "// only int ",
            "int convert_base_int(int x,int y){",
            "\tstring s;\n",
            "\twhile (x){",
            "\t\ts = to_string(x % y) + s;",
            "\t\tx /= y;",
            "\t}",
            "\treturn atoi(s.c_str());",
            "}",
        ],
        "description":[
            "Library for base conversion",
            "Convert decimal x to base y notation and return",
            "Does not handle negative numbers",
            "Since it returns in string type, use convert_base.c_str() to pass to functions expecting a different type "],
    },
    "Prime factorization":{
        "prefix": "fprifa",
        "body": [
            "vector<pair<ll,int>> prime_fac(ll n){",
            "\tvector<pair<ll,int>> res;",
            "\tfor(ll i = 2;i*i <= n;i++){",
            "\t\tint cnt = 0;",
            "\t\twhile(n%i == 0){",
            "\t\t\tcnt++;",
            "\t\t\tn /= i;",
            "\t\t}",
            "\tif(cnt != 0) res.emplace_back(make_pair(i,cnt));",
            "\t}",
            "\tif(n != 1) res.emplace_back(n,1);\n",
            "\treturn res;",
            "}",
            ],
        "description":[
            "(prime factor, count of the prime factor) pair",
            "Returns prime factorization as a vector of pairs of factors and their counts"
        ] ,
    },
    "gcd,lcm":{
        "prefix": "gcdlcm",
        "body": [
            "template <class T>",
            "T GCD(T a, T b) {",
            "\tif (b == 0)",
            "\t\treturn a;",
            "\telse",
            "\t\treturn GCD(b, a % b);",
            "}\n",
            "template <class T>",
            "inline T LCM(T a, T b) {",
            "\t return b / GCD(a, b) * a;",
            "}\n",
        ],
    },
    "editdistance": {
        "prefix": "editdist",
        "body": [
        "int editdistance(string s1,string s2){",
        "\tint a = s1.size(),b = s2.size(),cost;",
        "\tvector<vector<int>> dp(a+1,vector<int>(b+1,0));",
        "\trep(i,a+1) dp[i][0] = i;",
        "\trep(i,b+1) dp[0][i] = i;\n",
        "\trep(i,a){",
        "\t\trep(j,b){",
        "\t\t\tif(s1[i] == s2[j]) cost = 0;",
        "\t\t\telse cost = 1;",
        "\t\t\tdp[i+1][j+1] = min({dp[i+1][j]+1,dp[i][j+1]+1,dp[i][j]+cost});",
        "\t\t}",
        "\t}",
        "\treturn dp[a][b];",
        "}",
        ],
        "description": "edit distance"
    },
    "Grid0-1bsf": {
        "prefix": "fg01bsf",
        "body": [
            "int bfs01(P s, P g, vector<string> &c){",
            "\tint H = c.size();",
            "\tint W = c[0].size();",
            "\tvector<vector<int>> d(H, vector<int>(W, -1));",
            "\tdeque<P> que;",
            "\tque.push_front(s);",
            "\td[s.first][s.second] = 0;\n",
            "\twhile (que.size()){\n",
            "\t\tP p = que.front();",
            "\t\tque.pop_front();\n",
            "\t\trep(i, 4){",
            "\t\t\tint x = p.first + dx[i], y = p.second + dy[i];\n",
            "\t\t\tif (x < 0 || x >= H || y < 0 || y >= W)",
            "\t\t\t\tcontinue;",
            "\t\t\tif (d[x][y] != -1)",
            "\t\t\t\tcontinue;",
            "\t\t\tif (c[x][y] == '.' || c[x][y] == 'g'){",
            "\t\t\t\td[x][y] = d[p.first][p.second];",
            "\t\t\t\tque.push_front(make_pair(x,y));",
            "\t\t\t}",
            "\t\t\telse if(c[x][y] == '#'){",
            "\t\t\t\td[x][y] = d[p.first][p.second]+1;",
            "\t\t\t\tque.push_back(make_pair(x,y));",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn d[g.first][g.second];",
            "}",
        ],
        "description": [
            "/*0-1 Breadth-First Search",
            "(start, goal, maze)",
            "first is row, second is column",
            "only 4 directions",
            "'.' or 'g' is a path with no cost",
            "'#' is a path with cost*/"
        ]
    },
    "Gridbsf": {
        "prefix": "fgbsf",
        "body": [
            "int bfs(P s, P g, vector<string> &c)",
            "{",
            "\tint H = c.size();",
            "\tint W = c[0].size();",
            "\tvector<vector<int>> d(H, vector<int>(W, -1));",
            "\tqueue<P> que;",
            "\tque.push(s);",
            "\td[s.first][s.second] = 0;\n",
            "\twhile (que.size())",
            "\t{",
            "\t\tP p = que.front();",
            "\t\tque.pop();\n",
            "\t\trep(i, 4)",
            "\t\t{",
            "\t\t\tint x = p.first + dx[i], y = p.second + dy[i];\n",
            "\t\t\tif (x < 0 || x >= H || y < 0 || y >= W)",
            "\t\t\t\tcontinue;",
            "\t\t\tif (c[x][y] == '#')",
            "\t\t\t\tcontinue;",
            "\t\t\tif (d[x][y] != -1)",
            "\t\t\t\tcontinue;",
            "\t\t\tif (x == g.first && y == g.second)",
            "\t\t\t{",
            "\t\t\t\td[x][y] = d[p.first][p.second] + 1;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tque.push(P(x, y));",
            "\t\t\td[x][y] = d[p.first][p.second] + 1;",
            "\t\t}",
            "\t}",
            "\treturn d[g.first][g.second];",
            "}",
        ],
        "description": [
            "Breadth-First Search on a Grid Graph",
            "/*(start, goal, maze)",
            "first is row, second is column",
            "Cannot pass through '#' and can pass through anything else.",
            "Only 4 directions*/"
        ],
    },
    "dijkstra": {
        "prefix": "fdijk",
        "body": [
            "using TU = tuple<int,ll>;",
            "using Graph = vector<vector<TU>>;\n",
            "vector<ll> dijkstra(int s,Graph &G){",
            "\tint n = G.size();",
            "\tvector<ll> dist(n,lINF);",
            "\tdist[s] = 0;\n",
            "\tpriority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> que;",
            "\tque.push(make_pair(dist[s],s));\n",
            "\twhile(!que.empty()){",
            "\t\tint v;",
            "\t\tll d;",
            "\t\ttie(d,v) = que.top();",
            "\t\tque.pop();\n",
            "\t\tif(d > dist[v]) continue;",
            "\t\tfor(auto nxt:G[v]){",
            "\t\t\tint nv;",
            "\t\t\tll w;",
            "\t\t\ttie(nv,w) = nxt;",
            "\t\t\tif(chmin(dist[nv],dist[v]+w))",
            "\t\t\t\tque.push(make_pair(dist[nv], nv));",
            "\t\t}",
            "\t}",
            "\treturn dist;",
            "}",
        ],
        "description": "Note that s and G should be converted to 0-indexed."
    },
    "isPrime": {
        "prefix": "fisP",
        "body": [
        "bool isPrime(ll x){",
            "\tif(x < 2) return 0;",
            "\telse if(x == 2) return true;\n",
            "\tif(x%2 == 0) return false;",
            "\tfor(int i = 3;i*i <= x;i+=2){",
                "\t\tif(x%i == 0) return false;",
            "\t}",
            "\treturn true;",
        "}",
        ],
        "description": [
            "Prime number determination",
            "Determines if n is a prime number and returns a boolean."
        ],
    },
    "Longest Common Subsequence": {
        "prefix": "lcsfunc",
        "body": [
            "int lcs(string A,string B){",
            "\tint a = A.size(),b = B.size();",
            "\tvector<vector<int>> dp(a+1,vector<int>(b+1,0));",
            "\trep(i,a){",
            "\t\trep(j,b){",
            "\t\t\tif(A[i] == B[j]){",
            "\t\t\t\tdp[i+1][j+1] =dp[i][j]+1;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tdp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn dp[a][b];",
            "}",
        ],
    },
    "Palindrome check": {
        "prefix": "ispal",
        "body": [
            "bool ispal(string s){",
            "\tstring t = s;",
            "\treverse(t.begin(),t.end());",
            "\treturn s == t;",
            "}",
        ],
        "description": "Returns true if the input is a palindrome, otherwise returns false",
    },
    "forward Cumulative sum calculation ": {
        "prefix": "fcumsum",
        "body": [
            "vector<int> c(n+1);",
            "rep2(i,1,n+1) c[i] = c[i-1]+a[i-1];",
        ],
        "description": [
            "summing from the beginning",
            "For vector<int> a(n), where c[0] has no value"
        ]
    },
    "Backward Cumulative sum calculation": {
        "prefix": "bcumsum",
        "body": [
            "vector<int> a(n);",
            "vector<int> cm(n,0);",
            "for(int i = n-2;i >= 0;i--){",
            "\tcm[i] = c[i+1] + a[i];",
            "}",
        ],
        "description":[
            " cm[i] is the cumulative sum from index i to the end.",
            " Often used for cm[i] * a[i].",
            "summing from the end",
        ]
    },
    "bit search":{
        "prefix": "sbit",
        "body": [
        "rep(bit,(1<<$1)){",
        "\tll cnt = 0;\n",
        "\trep(i,$1){",
        "\t\tif(bit & (1<<i)){",
        "\t\t\t$2",
        "\t\t}",
        "\t}\n",
        "\t$3",
        "}\n",
        ],
    },
    "binary serach":{
        "prefix": "binse",
        "body": [
        "bool P(int x) {\n",
            // write conditions
        "}\n",
        "int binary_search(int l,int r) {",
            "\tint left, right; \n",
            "\twhile (right - left > 1) {",
                "\t\tint mid = left + (right - left) / 2;",
                "\t\tif (P(mid)) right = mid;",
                "\t\telse left = mid;",
            "\t}",
            "\treturn right;",
        "}\n",
        ],
        "description": [
            "Returns the smallest integer x for which P(x) = true",
            "Ensure P(left) = False and P(right) = True",
        ]
    }
}